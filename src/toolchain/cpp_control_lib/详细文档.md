# C++ PID控制器库详细文档

## 1. 控制器使用说明

### 1.1 基本使用流程

#### 1.1.1 包含头文件
```cpp
#include "pid_controller.hpp"
```

#### 1.1.2 创建控制器实例

##### 位置式PID控制器
```cpp
PIDController pid(kp, ki, kd, dt);
```

##### 增量式PID控制器
```cpp
IncrementalPIDController incremental_pid(kp, ki, kd, dt);
```

##### 模糊PID控制器
```cpp
FuzzyPIDController fuzzy_pid(kp, ki, kd, dt);
```

##### 自适应PID控制器
```cpp
// 使用默认学习率0.01
AdaptivePIDController adaptive_pid(kp, ki, kd, dt);

// 自定义学习率
AdaptivePIDController adaptive_pid(kp, ki, kd, dt, gamma);
```

#### 1.1.3 计算控制输出
```cpp
double setpoint = 1.0; // 设定值
double process_val = 0.0; // 当前过程值
double output = pid.compute(setpoint, process_val);
```

#### 1.1.4 重置控制器
```cpp
pid.reset();
```

### 1.2 控制器参数说明

| 参数 | 类型 | 描述 | 典型值范围 |
|------|------|------|------------|
| kp | double | 比例系数 | 0.1 - 10.0 |
| ki | double | 积分系数 | 0.01 - 1.0 |
| kd | double | 微分系数 | 0.001 - 1.0 |
| dt | double | 采样时间（秒） | 0.01 - 0.5 |
| gamma | double | 自适应学习率（仅自适应PID） | 0.001 - 0.1 |

### 1.3 使用示例

```cpp
#include "pid_controller.hpp"

int main() {
    // 初始化控制器
    PIDController pid(0.5, 0.1, 0.05, 0.1);
    
    // 设定值
    double setpoint = 1.0;
    // 当前过程值
    double process_val = 0.0;
    
    // 模拟控制循环
    for (int i = 0; i < 100; ++i) {
        // 计算控制输出
        double output = pid.compute(setpoint, process_val);
        
        // 更新过程值（模拟系统响应）
        process_val += output * 0.1;
        
        // 输出结果
        printf("Iteration %d: Setpoint=%.2f, ProcessVal=%.2f, Output=%.2f\n", 
               i, setpoint, process_val, output);
    }
    
    return 0;
}
```

## 2. API文档

### 2.1 Controller基类

#### 2.1.1 类定义
```cpp
class Controller {
public:
    virtual ~Controller() = default;
    virtual double compute(double setpoint, double process_val) = 0;
    virtual void reset() = 0;
};
```

#### 2.1.2 成员函数

| 函数名 | 返回类型 | 参数 | 描述 |
|--------|----------|------|------|
| `compute` | double | setpoint: 设定值<br>process_val: 当前过程值 | 计算控制输出，纯虚函数，子类必须实现 |
| `reset` | void | 无 | 重置控制器状态，纯虚函数，子类必须实现 |

### 2.2 PIDController类（位置式PID）

#### 2.2.1 构造函数
```cpp
PIDController(double kp_val, double ki_val, double kd_val, double dt_val);
```

| 参数 | 类型 | 描述 |
|------|------|------|
| kp_val | double | 比例系数 |
| ki_val | double | 积分系数 |
| kd_val | double | 微分系数 |
| dt_val | double | 采样时间（秒） |

#### 2.2.2 成员函数

| 函数名 | 返回类型 | 参数 | 描述 |
|--------|----------|------|------|
| `compute` | double | setpoint: 设定值<br>process_val: 当前过程值 | 计算位置式PID输出 |
| `reset` | void | 无 | 重置控制器的误差积分、前一次误差等状态 |

### 2.3 IncrementalPIDController类（增量式PID）

#### 2.3.1 构造函数
```cpp
IncrementalPIDController(double kp_val, double ki_val, double kd_val, double dt_val);
```

| 参数 | 类型 | 描述 |
|------|------|------|
| kp_val | double | 比例系数 |
| ki_val | double | 积分系数 |
| kd_val | double | 微分系数 |
| dt_val | double | 采样时间（秒） |

#### 2.3.2 成员函数

| 函数名 | 返回类型 | 参数 | 描述 |
|--------|----------|------|------|
| `compute` | double | setpoint: 设定值<br>process_val: 当前过程值 | 计算增量式PID输出 |
| `reset` | void | 无 | 重置控制器的前两次误差状态 |

### 2.4 FuzzyPIDController类（模糊PID）

#### 2.4.1 构造函数
```cpp
FuzzyPIDController(double kp_val, double ki_val, double kd_val, double dt_val);
```

| 参数 | 类型 | 描述 |
|------|------|------|
| kp_val | double | 初始比例系数 |
| ki_val | double | 初始积分系数 |
| kd_val | double | 初始微分系数 |
| dt_val | double | 采样时间（秒） |

#### 2.4.2 成员函数

| 函数名 | 返回类型 | 参数 | 描述 |
|--------|----------|------|------|
| `compute` | double | setpoint: 设定值<br>process_val: 当前过程值 | 计算模糊PID输出，根据误差和误差变化率动态调整PID参数 |
| `reset` | void | 无 | 重置控制器的误差积分、前一次误差等状态 |

### 2.5 AdaptivePIDController类（自适应PID）

#### 2.5.1 构造函数
```cpp
AdaptivePIDController(double kp_val, double ki_val, double kd_val, double dt_val, double gamma_val = 0.01);
```

| 参数 | 类型 | 描述 | 默认值 |
|------|------|------|--------|
| kp_val | double | 初始比例系数 | - |
| ki_val | double | 初始积分系数 | - |
| kd_val | double | 初始微分系数 | - |
| dt_val | double | 采样时间（秒） | - |
| gamma_val | double | 自适应学习率 | 0.01 |

#### 2.5.2 成员函数

| 函数名 | 返回类型 | 参数 | 描述 |
|--------|----------|------|------|
| `compute` | double | setpoint: 设定值<br>process_val: 当前过程值 | 计算自适应PID输出，使用MIT规则自动调整PID参数 |
| `reset` | void | 无 | 重置控制器的误差积分、前一次误差、前一次输出等状态 |

## 3. 算法原理介绍

### 3.1 基本PID控制算法

PID控制器的核心公式为：

```
u(t) = K_p e(t) + K_i ∫₀ᵗ e(τ) dτ + K_d de(t)/dt
```

其中：
- `u(t)`: 控制输出
- `K_p`: 比例系数
- `K_i`: 积分系数
- `K_d`: 微分系数
- `e(t)`: 误差，`e(t) = setpoint - process_val`

### 3.2 位置式PID

位置式PID直接计算控制输出的绝对量，适用于大部分控制系统。其离散化公式为：

```
u(k) = K_p e(k) + K_i T ∑₀ᵏ e(i) + (K_d / T)(e(k) - e(k-1))
```

其中：
- `T`: 采样时间
- `e(k)`: 当前时刻误差
- `e(k-1)`: 前一时刻误差
- `∑₀ᵏ e(i)`: 误差积分

### 3.3 增量式PID

增量式PID计算控制输出的变化量，适用于步进电机等需要增量控制的系统。其离散化公式为：

```
Δu(k) = u(k) - u(k-1) = K_p Δe(k) + K_i T e(k) + (K_d / T)(Δe(k) - Δe(k-1))
```

其中：
- `Δe(k) = e(k) - e(k-1)`: 误差变化
- `Δe(k-1) = e(k-1) - e(k-2)`: 前一时刻误差变化

### 3.4 模糊PID控制

模糊PID控制器通过模糊推理系统动态调整PID参数，提高系统的自适应能力。其工作原理如下：

1. **模糊化**：将误差`e`和误差变化率`ec`转换为模糊变量
2. **模糊规则推理**：基于49条模糊规则（7×7）确定PID参数调整量
3. **解模糊**：将模糊输出转换为精确的PID参数调整量
4. **参数更新**：更新PID参数，计算控制输出

模糊变量采用7个语言值：
- NB: 负大 (Negative Big)
- NM: 负中 (Negative Medium)
- NS: 负小 (Negative Small)
- ZO: 零 (Zero)
- PS: 正小 (Positive Small)
- PM: 正中 (Positive Medium)
- PB: 正大 (Positive Big)

### 3.5 自适应PID控制

自适应PID控制器基于MIT规则自动调整PID参数，使系统性能指标最优。其工作原理如下：

1. **性能指标计算**：计算系统性能指标`J = e²(t)`
2. **参数梯度计算**：计算性能指标对PID参数的偏导数
3. **参数更新**：根据MIT规则更新PID参数：
   ```
   ΔK_p = -γ ∂J/∂K_p
   ΔK_i = -γ ∂J/∂K_i
   ΔK_d = -γ ∂J/∂K_d
   ```
4. **参数限幅**：确保PID参数在合理范围内
5. **控制输出计算**：使用更新后的参数计算控制输出

## 4. 测试程序使用指南

### 4.1 测试程序简介

本项目提供了3个测试程序，用于验证和分析控制器性能：

| 测试程序 | 功能描述 |
|----------|----------|
| `test_pid.exe` | 极简测试，仅测试单个控制器，控制台输出结果 |
| `test_all_controllers_simple.exe` | 简化版综合测试，测试所有4种控制器，控制台输出详细响应数据 |
| `test_all_controllers.exe` | 完整综合测试，测试所有4种控制器，计算性能指标，生成CSV数据文件 |

### 4.2 编译测试程序

使用CMake构建系统编译测试程序：

```bash
# 创建构建目录
mkdir build
cd build

# 生成Makefile或Visual Studio解决方案
cmake ..

# 编译
cmake --build .
```

### 4.3 运行测试程序

#### 4.3.1 运行`test_all_controllers.exe`

```bash
# 基本运行（生成默认CSV文件名）
./test_all_controllers.exe

# 使用前缀避免文件覆盖
./test_all_controllers.exe run1

# 使用不同前缀运行多次，生成不同批次的数据
./test_all_controllers.exe run2
```

#### 4.3.2 命令行参数说明

| 参数 | 类型 | 描述 | 可选 | 默认值 |
|------|------|------|------|--------|
| 前缀 | string | CSV文件名前缀，用于区分不同批次的测试数据 | 是 | 空字符串 |

### 4.4 测试结果分析

#### 4.4.1 控制台输出

测试程序运行后，控制台将显示各控制器的性能指标：

```
=== Position PID Controller Performance Metrics ===
Rise Time: 0.00 seconds
Overshoot: 0.00%
Settling Time: 0.00 seconds
Steady State Error: 0.168147

=== Incremental PID Controller Performance Metrics ===
Rise Time: 0.00 seconds
Overshoot: 0.00%
Settling Time: 0.00 seconds
Steady State Error: 0.990099

=== Fuzzy PID Controller Performance Metrics ===
Rise Time: 18.60 seconds
Overshoot: 0.00%
Settling Time: 0.00 seconds
Steady State Error: 0.078720

=== Adaptive PID Controller Performance Metrics ===
Rise Time: 15.20 seconds
Overshoot: 0.00%
Settling Time: 0.00 seconds
Steady State Error: 0.040258
```

#### 4.4.2 CSV数据文件

测试程序生成4个CSV文件，包含控制器的详细响应数据：

| 文件名 | 描述 |
|--------|------|
| `pid_response.csv` | 位置式PID控制器响应数据 |
| `incremental_pid_response.csv` | 增量式PID控制器响应数据 |
| `fuzzy_pid_response.csv` | 模糊PID控制器响应数据 |
| `adaptive_pid_response.csv` | 自适应PID控制器响应数据 |

CSV文件格式：

| 列名 | 描述 |
|------|------|
| time | 时间（秒） |
| setpoint | 设定值 |
| process_val | 过程值 |
| output | 控制器输出 |

### 4.5 使用MATLAB分析测试结果

#### 4.5.1 运行MATLAB脚本

```matlab
% 运行控制器响应分析脚本
plot_controller_response.m

% 运行优化前后对比分析脚本（如果有优化前后的数据）
plot_optimized_comparison.m
```

#### 4.5.2 MATLAB脚本功能

| 脚本名 | 功能描述 |
|--------|----------|
| `plot_controller_response.m` | 读取CSV文件，绘制控制器响应曲线和性能指标，生成综合图表 |
| `plot_optimized_comparison.m` | 比较优化前后的控制器性能，生成对比图表 |
| `verify_plot_data.m` | 验证生成的图表数据是否符合预期结构 |

#### 4.5.3 生成的图表

| 图表名 | 描述 |
|--------|------|
| `controller_response_comparison.png` | 控制器响应曲线比较和性能指标柱状图 |
| `optimized_vs_original_comparison.png` | 优化前后的响应曲线对比图 |
| `steady_state_error_comparison.png` | 稳态误差对比柱状图 |

## 5. 性能指标说明

### 5.1 上升时间（Rise Time）

定义：系统从10%的设定值上升到90%的设定值所需的时间。

计算公式：
- 找到第一个超过10%设定值的时刻`t10`
- 找到第一个超过90%设定值的时刻`t90`
- 上升时间 = `t90 - t10`

### 5.2 超调量（Overshoot）

定义：系统输出超过设定值的最大百分比。

计算公式：
```
Overshoot = ((max_value - setpoint) / setpoint) × 100%
```

其中：
- `max_value`: 系统输出的最大值
- `setpoint`: 设定值

### 5.3 调节时间（Settling Time）

定义：系统输出进入并保持在设定值的2%误差带内所需的时间。

计算公式：
- 找到第一个时刻`t`，使得从`t`开始，所有后续输出值都在`[0.98×setpoint, 1.02×setpoint]`范围内
- 调节时间 = `t`

### 5.4 稳态误差（Steady State Error）

定义：系统达到稳态后，输出值与设定值之间的差值。

计算公式：
```
Steady State Error = |setpoint - steady_state_val|
```

其中：
- `steady_state_val`: 系统稳态输出值

## 6. 控制器性能对比

### 6.1 一阶系统模型测试结果

| 控制器类型 | 上升时间 (s) | 超调量 (%) | 调节时间 (s) | 稳态误差 |
|------------|--------------|------------|--------------|----------|
| Position PID | 0.00 | 0.00 | 0.00 | 0.168147 |
| Incremental PID | 0.00 | 0.00 | 0.00 | 0.990099 |
| Fuzzy PID | 18.60 | 0.00 | 0.00 | 0.078720 |
| Adaptive PID | 15.20 | 0.00 | 0.00 | 0.040258 |

**注**：
- 调节时间为0.00秒表示控制器在20秒仿真时间内未达到2%误差带
- 上升时间为0.00秒表示Position PID和Incremental PID未达到90%的设定值
- Adaptive PID表现最佳，具有最低的稳态误差
- Incremental PID表现较差，具有最高的稳态误差
- 所有控制器均无超调

### 6.2 控制器选择建议

| 控制器类型 | 适用场景 | 优点 | 缺点 |
|------------|----------|------|------|
| Position PID | 大部分控制系统，尤其是需要精确位置控制的系统 | 算法简单，实现容易，控制精度高 | 积分饱和问题，参数调整需要经验 |
| Incremental PID | 步进电机控制，阀门控制等需要增量输出的系统 | 无积分饱和问题，输出平稳，抗干扰能力强 | 控制精度相对较低，易受累计误差影响 |
| Fuzzy PID | 非线性系统，参数时变系统，复杂控制系统 | 自适应能力强，鲁棒性好，适合复杂系统 | 模糊规则设计复杂，计算量较大 |
| Adaptive PID | 未知系统，参数变化大的系统，需要自动调整参数的系统 | 自动调整参数，适应系统变化，控制效果好 | 算法复杂，计算量大，参数设计需要经验 |

## 7. 系统模型说明

### 7.1 一阶系统模型

本测试程序使用的是一阶系统模型：

传递函数：
```
G(s) = K / (T s + 1)
```

微分方程：
```
dx/dt = (K u - x) / T
```

其中：
- `G(s)`: 系统传递函数
- `K`: 系统增益
- `T`: 时间常数
- `u`: 系统输入
- `x`: 系统输出

### 7.2 仿真方法

使用欧拉方法数值求解一阶微分方程：

```
x(k+1) = x(k) + (dt / T) * (K * u(k) - x(k))
```

其中：
- `dt`: 采样时间
- `u(k)`: 当前时刻输入
- `x(k)`: 当前时刻输出
- `x(k+1)`: 下一时刻输出

## 8. 代码结构与扩展指南

### 8.1 代码结构

```
cpp_control_lib/
├── include/            # 头文件
│   ├── controller_base.hpp  # 控制器基类
│   └── pid_controller.hpp   # PID控制器实现
├── src/               # 源文件
│   └── pid_controller.cpp   # PID控制器实现
├── tests/             # 测试程序
│   ├── test_pid.cpp          # 极简测试
│   ├── test_all_controllers.cpp  # 完整综合测试
│   ├── test_all_controllers_simple.cpp  # 简化综合测试
│   └── test_simple.cpp       # 简单测试
├── CMakeLists.txt     # CMake构建配置
└── task_progress.md   # 任务进度文档
```

### 8.2 扩展新控制器

1. **创建新控制器类**：继承自`Controller`基类
2. **实现纯虚函数**：实现`compute()`和`reset()`方法
3. **添加到测试程序**：在`test_all_controllers.cpp`中添加新控制器的测试代码
4. **更新CMakeLists.txt**：如果需要，更新构建配置
5. **测试新控制器**：编译并运行测试程序，验证新控制器的性能

### 8.3 扩展系统模型

1. **创建新系统模型类**：类似`FirstOrderSystem`类
2. **实现系统计算方法**：实现系统的动态响应计算
3. **更新测试程序**：在测试程序中使用新的系统模型
4. **测试系统模型**：运行测试程序，验证新系统模型的响应

## 9. 注意事项

### 9.1 参数调整建议

1. **经验法（Ziegler-Nichols）**：
   - 先将`K_i`和`K_d`设为0，逐渐增加`K_p`直到系统出现等幅振荡
   - 记录此时的临界增益`K_u`和临界振荡周期`T_u`
   - 根据控制器类型选择合适的参数公式：
     - 位置式PID：`K_p = 0.6 K_u`, `K_i = 1.2 K_u / T_u`, `K_d = 0.075 K_u T_u`
     - 增量式PID：`K_p = 0.45 K_u`, `K_i = 0.54 K_u / T_u`, `K_d = 0.027 K_u T_u`

2. **试凑法**：
   - 先将`K_i`和`K_d`设为0，调整`K_p`使系统有较快的响应
   - 调整`K_i`消除稳态误差
   - 调整`K_d`减小超调和振荡
   - 重复调整，直到性能满意

### 9.2 积分饱和问题

积分饱和是PID控制器常见的问题，当系统长时间存在误差时，积分项会累积到很大的值，导致控制器输出超出范围。

解决方法：
1. **积分限幅**：限制积分项的最大值和最小值
2. **积分分离**：当误差较大时，不使用积分项；当误差较小时，使用积分项
3. **抗积分饱和**：当控制器输出达到限值时，停止积分累积

### 9.3 采样时间选择

采样时间的选择对PID控制器性能有很大影响：

1. **采样时间过小**：
   - 优点：控制精度高，响应快
   - 缺点：计算量大，浪费资源，易受噪声影响

2. **采样时间过大**：
   - 优点：计算量小，资源消耗少
   - 缺点：控制精度低，响应慢，可能导致系统不稳定

3. **建议采样时间**：
   - 对于一阶系统，采样时间应小于时间常数的1/10
   - 对于二阶系统，采样时间应小于阻尼振荡周期的1/20
   - 一般建议采样时间在0.01秒到0.5秒之间

## 10. 常见问题与解决方案

### 10.1 编译错误

| 错误类型 | 可能原因 | 解决方案 |
|----------|----------|----------|
| 缺少头文件 | 头文件路径不正确，或未包含必要的头文件 | 检查头文件路径，确保包含所有必要的头文件 |
| 语法错误 | 代码中存在语法错误 | 仔细检查代码，修复语法错误 |
| 链接错误 | 未正确链接库文件，或函数声明与定义不匹配 | 检查CMakeLists.txt，确保正确链接库文件，检查函数声明与定义是否匹配 |

### 10.2 运行错误

| 错误类型 | 可能原因 | 解决方案 |
|----------|----------|----------|
| 除零错误 | 采样时间`dt`设为0，或时间常数`T`设为0 | 确保`dt`和`T`大于0 |
| 内存错误 | 数组越界，或指针未初始化 | 检查代码，确保数组访问合法，指针正确初始化 |
| 计算溢出 | 控制器输出超出数据类型范围 | 增加输出限幅，或使用更大的数据类型 |

### 10.3 控制器性能问题

| 问题现象 | 可能原因 | 解决方案 |
|----------|----------|----------|
| 响应太慢 | `K_p`过小，或`K_i`过小 | 增大`K_p`，或增大`K_i` |
| 超调过大 | `K_p`过大，或`K_d`过小 | 减小`K_p`，或增大`K_d` |
| 振荡剧烈 | `K_p`过大，或`K_d`过大 | 减小`K_p`，或减小`K_d` |
| 稳态误差大 | `K_i`过小 | 增大`K_i` |
| 积分饱和 | 积分项累积过大 | 添加积分限幅，或使用积分分离技术 |

## 11. 总结

本项目实现了一个可扩展的C++ PID控制器库，包含4种控制器类型：位置式PID、增量式PID、模糊PID和自适应PID。库具有统一的接口设计，便于扩展和使用。

主要特点：
1. **统一接口**：所有控制器遵循相同的调用方式，便于切换和扩展
2. **多种控制器类型**：支持4种常用的PID控制器类型，满足不同应用需求
3. **完整的测试框架**：提供了3个测试程序，从简单到复杂，全面验证控制器性能
4. **可视化工具**：提供MATLAB脚本，用于分析和可视化控制器响应
5. **性能指标计算**：自动计算上升时间、超调量、调节时间和稳态误差
6. **CSV数据保存**：支持生成CSV数据文件，便于后续分析和处理
7. **命令行参数支持**：支持添加前缀，避免文件覆盖

使用本库，可以快速实现各种PID控制器，并进行性能测试和分析。库的设计具有良好的扩展性，可以方便地添加新的控制器类型和系统模型。

建议根据具体应用场景选择合适的控制器类型，并通过实验调整参数，以获得最佳的控制效果。